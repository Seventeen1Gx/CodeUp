# 从一些题目中得到的启发

- [1039 词组缩写](http://codeup.cn/problem.php?id=1039)

对于文本处理中的单词问题，我习惯于定义一个表示状态的变量，

```c
#define IN 1
#define OUT 0
int state = OUT;		//初值为OUT，表示在单词外
```

state用于在字符数组按序遍历时，跟踪当前访问位置，当`state = OUT`表示在单词外，当`state = IN`表示在单词内。条件`state == OUT && isalpha(s[i]) == true`满足时，说明此时进入一个单词，将state置为IN，条件`state == IN && isalpha(s[i]) == false`满足时，说明此时离开一个单词，state置为OUT。

* [1045 讨厌的小数点](http://codeup.cn/problem.php?id=1045)

`strlen()`判断字符串长度是根据末尾的\0来识别字符串的结束的。

本题一个比较重要的点是，如果询问的小数点后位数大于已有的位数，那就视为0。如对于1.345，小数点后1位是3，2位是4，3位是5，4位且4位之后是0。

`scanf()`录入字符串是会在结尾自动加上\0，本题要将其换成字符0，即'0'。

* [1051 破译邮件](http://codeup.cn/problem.php?id=1051)

之前所做字符处理都是1位1位的处理，有点思维定势了。本题出现2位一起处理的情况，给了一种遍历新思路。如：

```c
//方法一
for (int i = 0; s[i] != '\0'; i++)
	//To do something

//方法二
int i = 0;
while (s[i] != '\0')
	//在循环中看情况移动游标i
```

还有就是准备一个数组统计结果，每次结果往里丢，游标后移也是一种处理结果的常见手段。如：

```c
a[i] = result;
i++;
```

* [1053 幂字符串](http://codeup.cn/problem.php?id=1053)

首先明确，字符串s若可以化为a^n形式，则`strlen(s) = n * strlen(a)`。

且字符串s以小字符串a重复n次的形式存在，每小段下标之间是有规律的：每个小段a长度相同，且开始下标都是`strlen(a) * i (i = 0, 1， 2，…… ，n-1)`。如：

```c
a b a b a b a b = (a b) ^ 4
0 1 2 3 4 5 6 7						 //下标
```

每个小段ab长度为2，且开始下标都是` 2 * i (i = 0，1，3)`。

此外，因为要找最大的n，故n要从大到小试探，找到符合要求的就结束。

**注意：只有输入为`.`才退出，而输入`.abce`是不应该退出的，后者也是合法输入。（>,<）**

* [1055 字符串匹配](http://codeup.cn/problem.php?id=1055)

对于旋转字符串的操作，即循环左移p位，只需进行三次逆置操作：逆置0到p部分，逆置p+1到n-1部分，最后逆置整个字符串。

本题模式串所有的旋转形式可能会有相同的情况，如aaa，怎么旋转都是aaa，对于主串baaab，只匹配一次。如果每次循环左移模式串一位，再去和主串baaab寻求匹配，那么就会得到有4次匹配成功。但其实答案只有一次。即匹配的情况就会重复计算。我采用的方法是，由于在匹配时，考虑到主串中匹配成功的部分的长度就是模式串的长度，那么对于匹配结果，只要记住成功匹配时开始的匹配位置即可，每个位置匹配成功的情况统计一次即可。当这个位置的匹配是第一次出现，匹配结果数就加一，否则就不统计。这个可以用标记数组来标记主串的每个位置是否是匹配成功开始的位置。

